<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>hoplite.game.state API documentation</title>
<meta name="description" content="Gathering of all of the game components." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hoplite.game.state</code></h1>
</header>
<section id="section-intro">
<p>Gathering of all of the game components.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Gathering of all of the game components.
&#34;&#34;&#34;

import enum
import copy
import logging
import hoplite.utils
import hoplite.game.terrain
import hoplite.game.status
import hoplite.game.moves


LOGGER = logging.getLogger(__name__)


@enum.unique
class Interface(enum.Enum):
    &#34;&#34;&#34;Enumeration of possible game interface displayed on screen.
    &#34;&#34;&#34;

    EMBARK = 0
    PLAYING = 1
    ALTAR = 2
    FLEECE = 3
    VICTORY = 4
    DEATH = 5
    STAIRS = 6


class GameState:
    &#34;&#34;&#34;Logical representation of a game state.

    Attributes
    ----------
    depth : int
        Current level depth.
    terrain : hoplite.game.terrain.Terrain
        Logical representation of the terrain.
    status : hoplite.game.status.Status
        Logical representation of the player status.

    &#34;&#34;&#34;

    def __init__(self):
        self.depth = 1
        self.terrain = hoplite.game.terrain.Terrain()
        self.status = hoplite.game.status.Status()

    def __repr__(self):
        return &#34;%d %s %s&#34; % (self.depth, repr(self.terrain), repr(self.status))

    def __str__(self):
        return &#34;GameState%s&#34; % self.__dict__

    def __eq__(self, other):
        return (self.depth == other.depth
                and self.terrain == other.terrain
                and self.status == other.status)

    def __hash__(self):
        return hash(self.depth + hash(self.terrain) + hash(self.status))

    @classmethod
    def from_string(cls, string):
        &#34;&#34;&#34;Create and return a `GameState` object from its string representation.

        Parameters
        ----------
        string : str
            String representation of the game state, composed of three parts
            separated by spaces. First part is an integer corresponding to the
            current depth. Second part is the string representation of the
            `hoplite.game.terrain.Terrain`. Last part is the string
            representation of the `hoplite.game.status.Status`.

        Returns
        -------
        GameState
            Game state corresponding to that state.

        &#34;&#34;&#34;
        state = cls()
        depth, terrain_string, status_string = string.split(&#34; &#34;)
        state.depth = int(depth)
        state.terrain = hoplite.game.terrain.Terrain.from_string(terrain_string)
        state.status = hoplite.game.status.Status.from_string(status_string)
        return state

    def copy(self):
        &#34;&#34;&#34;Copy the current state.

        Returns
        -------
        GameState
            Same state with different address.

        &#34;&#34;&#34;
        return copy.deepcopy(self)

    def update(self, new_state):
        &#34;&#34;&#34;Update the current state with a newly parsed one.

        Parameters
        ----------
        new_state : GameState
            New game state, recently parsed.

        &#34;&#34;&#34;
        self.depth = new_state.depth
        self.terrain = new_state.terrain
        self.status.update(new_state.status)

    def apply_attacks(self, prev_state, attacks):
        &#34;&#34;&#34;Resolve player attacks.

        Parameters
        ----------
        prev_state : GameState
            State of the game before the last move.
        attacks : list[hoplite.game.attacks.PlayerAttack]
            Player attacks to consider.

        Rerturns
        --------
        int
            Total number of demons killed by the attacks.

        &#34;&#34;&#34;
        killed = 0
        for atck in attacks:
            killed += atck.apply(prev_state, self)
        return killed

    def possible_moves(self):
        &#34;&#34;&#34;Enumerates all possible moves for the player in the current state.

        Returns
        -------
        Iterator[hoplite.game.moves.PlayerMove]
            Legal moves for the player in the current game state.

        &#34;&#34;&#34;
        def cannot_land_on(pos):
            return (self.terrain.surface.get(pos) == hoplite.game.terrain.Tile.MAGMA)\
                or (pos == self.terrain.altar)\
                or (pos in self.terrain.bombs)\
                or (pos in self.terrain.demons)
        for pos in hoplite.utils.hexagonal_neighbors(self.terrain.player):
            if cannot_land_on(pos):
                continue
            yield hoplite.game.moves.WalkMove(pos)
        if self.status.can_leap():
            for pos in hoplite.utils\
                    .hexagonal_circle(
                            self.terrain.player,
                            self.status.attributes.leap_distance)\
                    .difference(hoplite.utils.hexagonal_circle(self.terrain.player, 1)):
                if cannot_land_on(pos):
                    continue
                yield hoplite.game.moves.LeapMove(pos)
        if self.status.can_bash():
            for pos in hoplite.utils.hexagonal_neighbors(self.terrain.player):
                yield hoplite.game.moves.BashMove(pos)
        if self.status.can_throw():
            for pos in hoplite.utils.hexagonal_circle(
                    self.terrain.player,
                    self.status.attributes.throw_distance):
                if (self.terrain.surface.get(pos) == hoplite.game.terrain.Tile.MAGMA)\
                        or (pos == self.terrain.altar)\
                        or (pos in self.terrain.bombs):
                    continue
                yield hoplite.game.moves.ThrowMove(pos)
        if self.terrain.altar_prayable\
                and self.terrain.altar in hoplite.utils.hexagonal_neighbors(self.terrain.player):
            yield hoplite.game.moves.AltarMove(self.terrain.altar)
        if hoplite.game.status.Prayer.PATIENCE in self.status.prayers:
            yield hoplite.game.moves.IdleMove(self.terrain.player)


class LostGameException(Exception):
    &#34;&#34;&#34;
    Exception to be raised when the game is lost.
    &#34;&#34;&#34;


class AltarState:  # pylint: disable=R0903
    &#34;&#34;&#34;Represent the state of an Altar.

    Attributes
    ----------
    prayers : dict[hoplite.game.status.Prayer, int]
            Prayers available at the altar, and their observed height
            (in pixels).

    &#34;&#34;&#34;

    def __init__(self):
        self.prayers = dict()

    def __str__(self):
        return str(list(self.prayers.keys()))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hoplite.game.state.AltarState"><code class="flex name class">
<span>class <span class="ident">AltarState</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represent the state of an Altar.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>prayers</code></strong> :&ensp;<code>dict[<a title="hoplite.game.status.Prayer" href="status.html#hoplite.game.status.Prayer">Prayer</a>, int]</code></dt>
<dd>Prayers available at the altar, and their observed height
(in pixels).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AltarState:  # pylint: disable=R0903
    &#34;&#34;&#34;Represent the state of an Altar.

    Attributes
    ----------
    prayers : dict[hoplite.game.status.Prayer, int]
            Prayers available at the altar, and their observed height
            (in pixels).

    &#34;&#34;&#34;

    def __init__(self):
        self.prayers = dict()

    def __str__(self):
        return str(list(self.prayers.keys()))</code></pre>
</details>
</dd>
<dt id="hoplite.game.state.GameState"><code class="flex name class">
<span>class <span class="ident">GameState</span></span>
</code></dt>
<dd>
<div class="desc"><p>Logical representation of a game state.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>depth</code></strong> :&ensp;<code>int</code></dt>
<dd>Current level depth.</dd>
<dt><strong><code>terrain</code></strong> :&ensp;<code><a title="hoplite.game.terrain.Terrain" href="terrain.html#hoplite.game.terrain.Terrain">Terrain</a></code></dt>
<dd>Logical representation of the terrain.</dd>
<dt><strong><code>status</code></strong> :&ensp;<code><a title="hoplite.game.status.Status" href="status.html#hoplite.game.status.Status">Status</a></code></dt>
<dd>Logical representation of the player status.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameState:
    &#34;&#34;&#34;Logical representation of a game state.

    Attributes
    ----------
    depth : int
        Current level depth.
    terrain : hoplite.game.terrain.Terrain
        Logical representation of the terrain.
    status : hoplite.game.status.Status
        Logical representation of the player status.

    &#34;&#34;&#34;

    def __init__(self):
        self.depth = 1
        self.terrain = hoplite.game.terrain.Terrain()
        self.status = hoplite.game.status.Status()

    def __repr__(self):
        return &#34;%d %s %s&#34; % (self.depth, repr(self.terrain), repr(self.status))

    def __str__(self):
        return &#34;GameState%s&#34; % self.__dict__

    def __eq__(self, other):
        return (self.depth == other.depth
                and self.terrain == other.terrain
                and self.status == other.status)

    def __hash__(self):
        return hash(self.depth + hash(self.terrain) + hash(self.status))

    @classmethod
    def from_string(cls, string):
        &#34;&#34;&#34;Create and return a `GameState` object from its string representation.

        Parameters
        ----------
        string : str
            String representation of the game state, composed of three parts
            separated by spaces. First part is an integer corresponding to the
            current depth. Second part is the string representation of the
            `hoplite.game.terrain.Terrain`. Last part is the string
            representation of the `hoplite.game.status.Status`.

        Returns
        -------
        GameState
            Game state corresponding to that state.

        &#34;&#34;&#34;
        state = cls()
        depth, terrain_string, status_string = string.split(&#34; &#34;)
        state.depth = int(depth)
        state.terrain = hoplite.game.terrain.Terrain.from_string(terrain_string)
        state.status = hoplite.game.status.Status.from_string(status_string)
        return state

    def copy(self):
        &#34;&#34;&#34;Copy the current state.

        Returns
        -------
        GameState
            Same state with different address.

        &#34;&#34;&#34;
        return copy.deepcopy(self)

    def update(self, new_state):
        &#34;&#34;&#34;Update the current state with a newly parsed one.

        Parameters
        ----------
        new_state : GameState
            New game state, recently parsed.

        &#34;&#34;&#34;
        self.depth = new_state.depth
        self.terrain = new_state.terrain
        self.status.update(new_state.status)

    def apply_attacks(self, prev_state, attacks):
        &#34;&#34;&#34;Resolve player attacks.

        Parameters
        ----------
        prev_state : GameState
            State of the game before the last move.
        attacks : list[hoplite.game.attacks.PlayerAttack]
            Player attacks to consider.

        Rerturns
        --------
        int
            Total number of demons killed by the attacks.

        &#34;&#34;&#34;
        killed = 0
        for atck in attacks:
            killed += atck.apply(prev_state, self)
        return killed

    def possible_moves(self):
        &#34;&#34;&#34;Enumerates all possible moves for the player in the current state.

        Returns
        -------
        Iterator[hoplite.game.moves.PlayerMove]
            Legal moves for the player in the current game state.

        &#34;&#34;&#34;
        def cannot_land_on(pos):
            return (self.terrain.surface.get(pos) == hoplite.game.terrain.Tile.MAGMA)\
                or (pos == self.terrain.altar)\
                or (pos in self.terrain.bombs)\
                or (pos in self.terrain.demons)
        for pos in hoplite.utils.hexagonal_neighbors(self.terrain.player):
            if cannot_land_on(pos):
                continue
            yield hoplite.game.moves.WalkMove(pos)
        if self.status.can_leap():
            for pos in hoplite.utils\
                    .hexagonal_circle(
                            self.terrain.player,
                            self.status.attributes.leap_distance)\
                    .difference(hoplite.utils.hexagonal_circle(self.terrain.player, 1)):
                if cannot_land_on(pos):
                    continue
                yield hoplite.game.moves.LeapMove(pos)
        if self.status.can_bash():
            for pos in hoplite.utils.hexagonal_neighbors(self.terrain.player):
                yield hoplite.game.moves.BashMove(pos)
        if self.status.can_throw():
            for pos in hoplite.utils.hexagonal_circle(
                    self.terrain.player,
                    self.status.attributes.throw_distance):
                if (self.terrain.surface.get(pos) == hoplite.game.terrain.Tile.MAGMA)\
                        or (pos == self.terrain.altar)\
                        or (pos in self.terrain.bombs):
                    continue
                yield hoplite.game.moves.ThrowMove(pos)
        if self.terrain.altar_prayable\
                and self.terrain.altar in hoplite.utils.hexagonal_neighbors(self.terrain.player):
            yield hoplite.game.moves.AltarMove(self.terrain.altar)
        if hoplite.game.status.Prayer.PATIENCE in self.status.prayers:
            yield hoplite.game.moves.IdleMove(self.terrain.player)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="hoplite.game.state.GameState.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a <code><a title="hoplite.game.state.GameState" href="#hoplite.game.state.GameState">GameState</a></code> object from its string representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>string</code></strong> :&ensp;<code>str</code></dt>
<dd>String representation of the game state, composed of three parts
separated by spaces. First part is an integer corresponding to the
current depth. Second part is the string representation of the
<code><a title="hoplite.game.terrain.Terrain" href="terrain.html#hoplite.game.terrain.Terrain">Terrain</a></code>. Last part is the string
representation of the <code><a title="hoplite.game.status.Status" href="status.html#hoplite.game.status.Status">Status</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hoplite.game.state.GameState" href="#hoplite.game.state.GameState">GameState</a></code></dt>
<dd>Game state corresponding to that state.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, string):
    &#34;&#34;&#34;Create and return a `GameState` object from its string representation.

    Parameters
    ----------
    string : str
        String representation of the game state, composed of three parts
        separated by spaces. First part is an integer corresponding to the
        current depth. Second part is the string representation of the
        `hoplite.game.terrain.Terrain`. Last part is the string
        representation of the `hoplite.game.status.Status`.

    Returns
    -------
    GameState
        Game state corresponding to that state.

    &#34;&#34;&#34;
    state = cls()
    depth, terrain_string, status_string = string.split(&#34; &#34;)
    state.depth = int(depth)
    state.terrain = hoplite.game.terrain.Terrain.from_string(terrain_string)
    state.status = hoplite.game.status.Status.from_string(status_string)
    return state</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hoplite.game.state.GameState.apply_attacks"><code class="name flex">
<span>def <span class="ident">apply_attacks</span></span>(<span>self, prev_state, attacks)</span>
</code></dt>
<dd>
<div class="desc"><p>Resolve player attacks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>prev_state</code></strong> :&ensp;<code><a title="hoplite.game.state.GameState" href="#hoplite.game.state.GameState">GameState</a></code></dt>
<dd>State of the game before the last move.</dd>
<dt><strong><code>attacks</code></strong> :&ensp;<code>list[<a title="hoplite.game.attacks.PlayerAttack" href="attacks.html#hoplite.game.attacks.PlayerAttack">PlayerAttack</a>]</code></dt>
<dd>Player attacks to consider.</dd>
</dl>
<h2 id="rerturns">Rerturns</h2>
<p>int
Total number of demons killed by the attacks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_attacks(self, prev_state, attacks):
    &#34;&#34;&#34;Resolve player attacks.

    Parameters
    ----------
    prev_state : GameState
        State of the game before the last move.
    attacks : list[hoplite.game.attacks.PlayerAttack]
        Player attacks to consider.

    Rerturns
    --------
    int
        Total number of demons killed by the attacks.

    &#34;&#34;&#34;
    killed = 0
    for atck in attacks:
        killed += atck.apply(prev_state, self)
    return killed</code></pre>
</details>
</dd>
<dt id="hoplite.game.state.GameState.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy the current state.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="hoplite.game.state.GameState" href="#hoplite.game.state.GameState">GameState</a></code></dt>
<dd>Same state with different address.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;Copy the current state.

    Returns
    -------
    GameState
        Same state with different address.

    &#34;&#34;&#34;
    return copy.deepcopy(self)</code></pre>
</details>
</dd>
<dt id="hoplite.game.state.GameState.possible_moves"><code class="name flex">
<span>def <span class="ident">possible_moves</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumerates all possible moves for the player in the current state.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterator[<a title="hoplite.game.moves.PlayerMove" href="moves.html#hoplite.game.moves.PlayerMove">PlayerMove</a>]</code></dt>
<dd>Legal moves for the player in the current game state.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def possible_moves(self):
    &#34;&#34;&#34;Enumerates all possible moves for the player in the current state.

    Returns
    -------
    Iterator[hoplite.game.moves.PlayerMove]
        Legal moves for the player in the current game state.

    &#34;&#34;&#34;
    def cannot_land_on(pos):
        return (self.terrain.surface.get(pos) == hoplite.game.terrain.Tile.MAGMA)\
            or (pos == self.terrain.altar)\
            or (pos in self.terrain.bombs)\
            or (pos in self.terrain.demons)
    for pos in hoplite.utils.hexagonal_neighbors(self.terrain.player):
        if cannot_land_on(pos):
            continue
        yield hoplite.game.moves.WalkMove(pos)
    if self.status.can_leap():
        for pos in hoplite.utils\
                .hexagonal_circle(
                        self.terrain.player,
                        self.status.attributes.leap_distance)\
                .difference(hoplite.utils.hexagonal_circle(self.terrain.player, 1)):
            if cannot_land_on(pos):
                continue
            yield hoplite.game.moves.LeapMove(pos)
    if self.status.can_bash():
        for pos in hoplite.utils.hexagonal_neighbors(self.terrain.player):
            yield hoplite.game.moves.BashMove(pos)
    if self.status.can_throw():
        for pos in hoplite.utils.hexagonal_circle(
                self.terrain.player,
                self.status.attributes.throw_distance):
            if (self.terrain.surface.get(pos) == hoplite.game.terrain.Tile.MAGMA)\
                    or (pos == self.terrain.altar)\
                    or (pos in self.terrain.bombs):
                continue
            yield hoplite.game.moves.ThrowMove(pos)
    if self.terrain.altar_prayable\
            and self.terrain.altar in hoplite.utils.hexagonal_neighbors(self.terrain.player):
        yield hoplite.game.moves.AltarMove(self.terrain.altar)
    if hoplite.game.status.Prayer.PATIENCE in self.status.prayers:
        yield hoplite.game.moves.IdleMove(self.terrain.player)</code></pre>
</details>
</dd>
<dt id="hoplite.game.state.GameState.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, new_state)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the current state with a newly parsed one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>new_state</code></strong> :&ensp;<code><a title="hoplite.game.state.GameState" href="#hoplite.game.state.GameState">GameState</a></code></dt>
<dd>New game state, recently parsed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, new_state):
    &#34;&#34;&#34;Update the current state with a newly parsed one.

    Parameters
    ----------
    new_state : GameState
        New game state, recently parsed.

    &#34;&#34;&#34;
    self.depth = new_state.depth
    self.terrain = new_state.terrain
    self.status.update(new_state.status)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hoplite.game.state.Interface"><code class="flex name class">
<span>class <span class="ident">Interface</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of possible game interface displayed on screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Interface(enum.Enum):
    &#34;&#34;&#34;Enumeration of possible game interface displayed on screen.
    &#34;&#34;&#34;

    EMBARK = 0
    PLAYING = 1
    ALTAR = 2
    FLEECE = 3
    VICTORY = 4
    DEATH = 5
    STAIRS = 6</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hoplite.game.state.Interface.ALTAR"><code class="name">var <span class="ident">ALTAR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hoplite.game.state.Interface.DEATH"><code class="name">var <span class="ident">DEATH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hoplite.game.state.Interface.EMBARK"><code class="name">var <span class="ident">EMBARK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hoplite.game.state.Interface.FLEECE"><code class="name">var <span class="ident">FLEECE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hoplite.game.state.Interface.PLAYING"><code class="name">var <span class="ident">PLAYING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hoplite.game.state.Interface.STAIRS"><code class="name">var <span class="ident">STAIRS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hoplite.game.state.Interface.VICTORY"><code class="name">var <span class="ident">VICTORY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hoplite.game.state.LostGameException"><code class="flex name class">
<span>class <span class="ident">LostGameException</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception to be raised when the game is lost.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LostGameException(Exception):
    &#34;&#34;&#34;
    Exception to be raised when the game is lost.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hoplite.game" href="index.html">hoplite.game</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hoplite.game.state.AltarState" href="#hoplite.game.state.AltarState">AltarState</a></code></h4>
</li>
<li>
<h4><code><a title="hoplite.game.state.GameState" href="#hoplite.game.state.GameState">GameState</a></code></h4>
<ul class="">
<li><code><a title="hoplite.game.state.GameState.apply_attacks" href="#hoplite.game.state.GameState.apply_attacks">apply_attacks</a></code></li>
<li><code><a title="hoplite.game.state.GameState.copy" href="#hoplite.game.state.GameState.copy">copy</a></code></li>
<li><code><a title="hoplite.game.state.GameState.from_string" href="#hoplite.game.state.GameState.from_string">from_string</a></code></li>
<li><code><a title="hoplite.game.state.GameState.possible_moves" href="#hoplite.game.state.GameState.possible_moves">possible_moves</a></code></li>
<li><code><a title="hoplite.game.state.GameState.update" href="#hoplite.game.state.GameState.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hoplite.game.state.Interface" href="#hoplite.game.state.Interface">Interface</a></code></h4>
<ul class="two-column">
<li><code><a title="hoplite.game.state.Interface.ALTAR" href="#hoplite.game.state.Interface.ALTAR">ALTAR</a></code></li>
<li><code><a title="hoplite.game.state.Interface.DEATH" href="#hoplite.game.state.Interface.DEATH">DEATH</a></code></li>
<li><code><a title="hoplite.game.state.Interface.EMBARK" href="#hoplite.game.state.Interface.EMBARK">EMBARK</a></code></li>
<li><code><a title="hoplite.game.state.Interface.FLEECE" href="#hoplite.game.state.Interface.FLEECE">FLEECE</a></code></li>
<li><code><a title="hoplite.game.state.Interface.PLAYING" href="#hoplite.game.state.Interface.PLAYING">PLAYING</a></code></li>
<li><code><a title="hoplite.game.state.Interface.STAIRS" href="#hoplite.game.state.Interface.STAIRS">STAIRS</a></code></li>
<li><code><a title="hoplite.game.state.Interface.VICTORY" href="#hoplite.game.state.Interface.VICTORY">VICTORY</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hoplite.game.state.LostGameException" href="#hoplite.game.state.LostGameException">LostGameException</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>